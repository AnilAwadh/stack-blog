---
layout: post
title: 'Podcast #41'
date: 2009-02-12 06:52:12.000000000 -05:00
categories:
- podcasts
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  _podPressMedia: a:1:{i:0;a:10:{s:3:"URI";s:82:"http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode41-2009.01.10.mp3";s:5:"title";s:10:"Podcast
    41";s:4:"type";s:9:"audio_mp3";s:4:"size";s:8:"30844507";s:8:"duration";s:8:"01:04:12";s:12:"previewImage";s:85:"http://blog.stackoverflow.com/wp-content/plugins/podpress//images/vpreview_center.png";s:10:"dimensionW";s:3:"320";s:10:"dimensionH";s:3:"240";s:3:"rss";s:2:"on";s:4:"atom";s:2:"on";}}
  _podPressPostSpecific: a:6:{s:15:"itunes:subtitle";s:15:"##PostExcerpt##";s:14:"itunes:summary";s:15:"##PostExcerpt##";s:15:"itunes:keywords";s:17:"##WordPressCats##";s:13:"itunes:author";s:10:"##Global##";s:15:"itunes:explicit";s:2:"No";s:12:"itunes:block";s:2:"No";}
author:
  login: admin
  email: jatwood@codinghorror.com
  display_name: Jeff Atwood
  first_name: Jeff
  last_name: Atwood
excerpt: !ruby/object:Hpricot::Doc
  options: {}
---
<p>This is the 41st episode of the StackOverflow podcast, where Joel and Jeff sit down with <a href="v">Robert Martin aka "Uncle Bob"</a>, and discuss software quality, the value of software engineering principles, and test-driven development.</p>
<ul>
<li>Joel clarifies that <a href="http://www.joelonsoftware.com/items/2009/01/31.html">some of his comments</a> in <a href="http://blog.stackoverflow.com/2009/01/podcast-38/">Podcast #38</a> were a bit unintentionally ad-hominem, and apologizes to Uncle Bob for that -- see <a href="http://blog.objectmentor.com/articles/2009/02/06/on-open-letter-to-joel-spolsky-and-jeff-atwood">Bob's open letter blog post</a>. But on the positive side, it did get us a podcast with Uncle Bob!</li>
<li>This was a big week for Stack Overflow; we <a href="http://blog.stackoverflow.com/2009/02/new-datacenter-migration/">moved to a new hosting provider</a> -- <a href="http://www.peakinternet.com/business/hosting/info.php">PEAK Internet</a> in Corvallis. We did have a few blips with DNS but other than that the move was relatively smooth.</li>
<li>Increasing our servers from 4 GB (web) and 4 GB (database) to 8 GB and 24 GB, respectively, opened up tons of breathing room and unleashed a lot of latent performance. Memory is <em>incredibly</em> cheap right now; there's no reason not to install ridiculous amounts. It is (almost) free performance. Bob reminisces about when he bought memory by the <strong>bit</strong>!</li>
<li>When <a href="http://blog.objectmentor.com/articles/2009/01/31/quality-doesnt-matter-that-much-jeff-and-joel">I said "quality doesn't matter"</a>, I didn't mean it literally. If you deliver a software product that nobody likes or wants to use, it doesn't matter how great the quality of your code is. You can always fix code quality -- but fixing "nobody gives a crap about our product" is far more difficult. That's what you should be worrying about most of all.</li>
<li>Quality has many dimensions. The cleanest code in the world could utterly miss the point on usability, scalability, performance, and meeting users' expectations.</li>
<li>On the other hand, as Bob points out, there are companies that have shipped broken products which permanently damaged their reputations and, in some cases, even forced themselves out of business.</li>
<li>Bob's <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID principles</a> are based on some well known conventions. I talked about the first one, the Single Responsibility Principle, in <a href="http://www.codinghorror.com/blog/archives/000805.html">Curly's Law: Do One Thing</a>. You may have heard this before as Don't Repeat Yourself (DRY), Once and Only Once, or Single Point of Truth.</li>
<li>We wonder if some of these guidlines -- such as "deploy independently" -- are obviated by the inevitable forward march of technology, such as software delivered through the cloud, and virtual machines.</li>
<li>What happens when principles fall into the hands of people who don't really know what they're doing? Or people who become bureaucrats, rigidly enforcing rules on everyone? We think the existence of rules, in and of itself, isn't necessarily a net good. The types of developers who need those rules are <a href="http://www.codinghorror.com/blog/archives/001004.html">often immune to them</a>.</li>
<li>Often, software developed internally doesn't have to be good; users are forced to use it. This software would never survive as a real product that had users who actually had to want to pay for and use the software. Bob is fond of asking "why is open source software so much better"; part of the reason is that this software has to survive in the real world on its own merits to garner users and attentions. It's not isolated on some peculiar little corporate Galapagos island where it has no competition.</li>
<li>Joel worries that excessive TDD (say, going from 90% to 100% test coverage) cuts time from other activities that could benefit the software product, such as better usability or additional features users are clamoring for.</li>
<li>Unit tests are absolutely useful as a form of "eating your own dogfood", and documenting the behavior of your system. Even if you disregard the actual results of the tests completely, they're still valuable as documentation and giving you a fresh outside perspective on your codebase.</li>
<li>Joel notes the difficulty of testing the UI (web or executable) versus testing the code behind the UI. The classic method of doing this is probably documented in <a href="http://catb.org/~esr/writings/taoup/html/">The Art of UNIX Programming</a>, where you start with a command-line app that takes in and spits out text. The GUI is simply a layer you paste on top of the command-line app, which leads to perfect testability -- but perhaps not such great apps, in the long run. Which is more important?</li>
<li>The hidden context of wondering whether a large switch statement you've written is the right choice is that <em>you've already won</em> -- the types of developers who are <a href="http://www.codinghorror.com/blog/archives/001020.html">actively thinking about their work</a> aren't really the problem.</li>
</ul>
<p>Our favorite Stack Overflow questions this week are:</p>
<ul>
<li><strong>Everyone</strong>: <a href="http://stackoverflow.com/questions/505454/large-switch-statements-bad-oop">Large Switch statements: Bad OOP?</a> The idea that giant switch statements are fundamentally evil is a bit of a knee-jerk reaction. It really depends how simple and straightforward you can make the switch statement.</li>
</ul>
<p>We answered one listener question on this podcast:</p>
<ol>
<li><strong>Andrew Davis</strong>: "My rule of thumb is that unit tests should be written for clearly defined code that has highly constrained input going in and coming out. Is it even worth writing tests for GUI code?"</li>
<li><strong>Tim Kington</strong>: "True test-driven development has one benefit you didn't talk about: you can approach your code from the perspective of the client."</li>
</ol>
<p>
If you'd like to submit a question to be answered in our next episode, record an audio file (90 seconds or less) and mail it to <a href="mailto:podcast@stackoverflow.com">podcast@stackoverflow.com</a>. You can <a href="http://blog.stackoverflow.com/index.php/2008/05/recording-podcast-questions-using-your-telephone/">record a question</a> using nothing but a telephone and a web browser. We also have a dedicated phone number you can call to leave audio questions at <strong>646-826-3879</strong>.</p>
<p>
The <a href="https://stackoverflow.fogbugz.com/default.asp?W29030">transcript wiki</a> for this episode is available for public editing.</p>
<p>
[display_podcast]</p>
